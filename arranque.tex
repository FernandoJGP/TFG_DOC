%!TEX root =  tfg.tex
\chapter{Arranque}

\begin{abstract}
Durante este capítulo de la memoria se presentará la lista de características que conforman el proyecto, así como el diseño arquitectónico de Unreal Engine, el motor gráfico elegido para llevar a cabo el proyecto.
\end{abstract}

\section{Lista de características}
La lista de características está confeccionada a partir del documento de diseño, incorporado como anexo a este documento (Ver apéndice \ref{sec:gdd}), por tanto, para encontrar una descripción más detallada tendremos que remitirnos a dicho anexo.

\begin{enumerate}
	\item Mecánica: Movimiento del personaje.
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Rotación del personaje.
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Sprint.
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Salto.
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Agachado.
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Tiempo bala (o "`Time dilation"').
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
		\item Gestión de adrenalina relacionada con la mecánica.
	\end{itemize}
	\item Mecánica: Parpadeo (o "`Blink"').
	\begin{itemize}
		\item Implementación del código de la mecánica.
		\item Asignación de teclas y botones vinculados la mecánica.
		\item Desarrollo de la animación del personaje relacionada con la mecánica.
		\item Gestión de adrenalina relacionada con la mecánica.
		\item Implementación del código del indicador de blink disponible.
	\end{itemize}
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
	\item .
\end{enumerate}

\clearpage

\section{Diseño arquitectónico}
\label{sec:arquitectura}

En el momento que hablamos de diseño arquitectónico en el marco de este proyecto estamos refiriéndonos indirectamente al diseño arquitectónico del \gls{motorgrafico} que estamos utilizando, "`Unreal Engine 4"'.

\subsection{Módulos de juego}

El \gls{motorgrafico} Unreal Engine 4 está compuesto por una colección de módulos y, de la misma forma, cada juego desarrollado en él está compuesto por uno o más módulos, denominados módulos de juego, que en realidad son \textbf{DLLs} \cite{uedoc}.

De esta manera, la arquitectura básica de un juego desarrollado con Unreal Engine 4 es la siguiente:

\begin{figure*}[htb]
	\centering
		\includegraphics[scale=0.8]{figures/ue4-arquitectura.png}
		\caption{Arquitectura Unreal Engine 4 \cite{uedoc}}
\end{figure*}

\clearpage

Como podemos apreciar, podemos estructurar nuestro proyecto en tantos módulos de juego como creamos necesario. Sin embargo, respecto a la creación de múltiples módulos de juego Epic Games nos hace saber:

\textit{Hay diferentes puntos de vista respecto a la separación en DLL. Separar el juego en un montón de archivos DLL puede tener más inconvenientes que beneficios, pero es una decisión que debe ser hecha por cada equipo de desarrollo basada en sus necesidades. Usar múltiples módulos de juego puede conducir en mejores tiempos de enlace e iteración de código más rápida, pero con más módulos será necesario lidiar con exportaciones de DLL e interfaces más a menudo. Esta concesión es la correcta para el motor y el editor, pero es cuestionable para el juego} \cite{uedoc}.

Como podemos apreciar, no hay una ventaja clara en usar varios módulos de juego, por lo que para la estructuración de este proyecto usaremos la opción más simple: usar un único módulo de juego, llamado "`TFG"' que contenga todas las clases de juego:

\begin{figure*}[htb]
	\centering
		\includegraphics[scale=0.8]{figures/proyecto-arquitectura.png}
		\caption{Estructura del proyecto}
\end{figure*}

\clearpage

\subsection{Clases de juego}

Cada módulo de juego contiene indeterminadas clases C++ y estas están compuestas por una clase cabecera ("`.h"') y una clase de archivo fuente ("`.cpp"'). La clase cabecera contiene las declaraciones de la clase y sus miembros, como variables y funciones, mientras que la clase de archivo fuente es donde la funcionalidad de la clase se define implementando las funciones que pertenecen a la clase \cite{uedoc}.

Además, cabe destacar que en Unreal Engine se usa un sistema de prefijos, que se seguirá en la medida de lo posible en el desarrollo de este proyecto. Los prefijos pueden ser:

\begin{table*}[h!]
	\centering
	\begin{coolTable}{lp{13cm}}{2}
{Prefijos de clases de gameplay en Unreal Engine}
	\textbf{Prefijo}&\textbf{Significado}\\
	\textbf{A}&Extiende desde la clase base "`spawneable"'. Son los denominados "`actores"', y pueden ser emplazados directamente en el mundo o escenario del juego.\\
	\textbf{U}&Extiende desde la clase base de todos los objetos de juego. No pueden ser instanciados directamente en el mundo, deben pertenecer a un "`actor"'. Son generalmente objetos como "`componentes"'.\\
	\end{coolTable}
	\caption{Prefijos de clases de juego en Unreal Engine \cite{uedoc}}
\end{table*}